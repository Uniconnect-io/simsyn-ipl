import { NextResponse } from 'next/server';
import db from '@/lib/db';
import OpenAI from "openai";
import crypto from 'crypto';

const openai = process.env.OPENAI_API_KEY ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY }) : null;

// Helper for cosine similarity
function dotProduct(vecA: number[], vecB: number[]) {
    return vecA.reduce((sum, val, i) => sum + val * (vecB[i] || 0), 0);
}

function cosineSimilarity(vecA: number[], vecB: number[]) {
    const magA = Math.sqrt(vecA.reduce((sum, val) => sum + val * val, 0));
    const magB = Math.sqrt(vecB.reduce((sum, val) => sum + val * val, 0));
    if (magA === 0 || magB === 0) return 0;
    return dotProduct(vecA, vecB) / (magA * magB);
}

async function getEmbedding(text: string) {
    if (!openai) return null;
    try {
        const response = await openai.embeddings.create({
            model: "text-embedding-3-small",
            input: text.replace(/\n/g, " "),
        });
        return response.data[0].embedding;
    } catch (e) {
        console.error('Embedding error:', e);
        return null;
    }
}

function calculateWeightedScore(scores: any) {
    return (
        scores.alignment * 0.25 +
        scores.feasibility * 0.2 +
        scores.value * 0.25 +
        scores.effort * 0.15 +
        scores.innovation * 0.15
    );
}

function convertToRuns(score: number) {
    if (score >= 85) return { runs: 6, wicket: false };
    if (score >= 75) return { runs: 4, wicket: false };
    if (score >= 60) return { runs: 2, wicket: false };
    if (score >= 50) return { runs: 1, wicket: false };
    if (score >= 40) return { runs: 0, wicket: false };
    return { runs: 0, wicket: true };
}

async function getAIScores(caseText: string, idea: string) {
    if (!openai) {
        // Mock scoring logic for testing
        // Penalize short inputs heavily in mock mode
        if (idea.length < 25) {
            return {
                alignment: 10 + Math.random() * 20,
                feasibility: 10 + Math.random() * 20,
                value: 5 + Math.random() * 15,
                effort: 5 + Math.random() * 10,
                innovation: 5 + Math.random() * 10
            };
        }

        const lengthFactor = Math.min(idea.length / 100, 1) * 30; // Better runs for longer ideas (up to 30)
        const base = 50 + Math.random() * 20; // 50-70 base
        return {
            alignment: base + (Math.random() * 10),
            feasibility: base + (Math.random() * 10),
            value: base + (Math.random() * 20),
            effort: base + (Math.random() * 15),
            innovation: base + lengthFactor
        };
    }

    console.log("--- OpenAI Scoring Request ---");
    console.log("Prompt:", `Case: ${caseText}\nIdea: ${idea}`);

    const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        response_format: { type: "json_object" },
        messages: [
            {
                role: "system",
                content: `You are a STRICT innovation judge.

Rules:
1. If the idea is completely unrelated to the case, return ALL scores = 0.
2. If the idea is nonsense (e.g., "adsf"), greeting (e.g., "hi"), or testing, return ALL scores = 0.
3. If the idea is generic but relevant, score it low (e.g., 30-50), DO NOT return 0.
4. Only return 0 if the input is truly invalid or spam.
4. Only score ideas that provide a concrete solution relevant to the case.
5. If unsure, return 0.
6. SCORING SCALE: 0 to 100 (where 0 is irrelevant, 100 is transformative).

Return JSON only.`
            },
            { role: "user", content: `Case: ${caseText}\nIdea: ${idea}\nReturn ONLY JSON: {"alignment": number (0-100), "feasibility": number (0-100), "value": number (0-100), "effort": number (0-100), "innovation": number (0-100)}` }
        ],
    });

    console.log("--- OpenAI Scoring Response ---");
    console.log(response.choices[0].message.content);

    return JSON.parse(response.choices[0].message.content!);
}

async function detectAIGenerated(text: string) {
    if (!openai) return { isAI: false, confidence: 0 };
    try {
        console.log("--- OpenAI Detection Request ---");

        const response = await openai.chat.completions.create({
            model: "gpt-4o-mini",
            response_format: { type: "json_object" },
            messages: [
                { role: "system", content: "You are an AI detection expert. Analyze the text and determine if it was likely generated by an LLM. NOTE: Bullet points, structured lists, and professional tone are COMMON in business ideas and should NOT be flagged as AI alone. Look for refusal patterns, 'As an AI', or extremely generic/robotic phrasing. Return JSON: {\"isAI\": boolean, \"confidence\": number (0-100)}" },
                { role: "user", content: text }
            ],
        });

        console.log("--- OpenAI Detection Response ---");
        console.log(response.choices[0].message.content);

        return JSON.parse(response.choices[0].message.content!);
    } catch (e) {
        console.error('AI Detection error:', e);
        return { isAI: false, confidence: 0 };
    }
}

export async function POST(request: Request) {
    try {
        const { matchId, teamId, captainId, content } = await request.json();

        if (!matchId || !teamId || !content) {
            return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
        }

        // 1. Validate Match State
        const matchRs = await db.execute({
            sql: 'SELECT * FROM matches WHERE id = ?',
            args: [matchId]
        });
        const match = matchRs.rows[0] as any;

        if (!match || match.status !== 'IN_PROGRESS') {
            return NextResponse.json({ error: 'Match is not in progress' }, { status: 400 });
        }

        const now = new Date();
        const isTeam1 = match.team1_id === teamId;
        const currentWickets = isTeam1 ? match.wickets1 : match.wickets2;
        if (currentWickets >= 10) {
            return NextResponse.json({ error: 'All wickets lost. Submission blocked.' }, { status: 400 });
        }

        // 2. HARD VALIDATION (Pre-AI)
        // Basic content validation
        if (!content || content.trim().length < 20) {
            return NextResponse.json({
                success: true,
                runs: 0,
                wicket: true,
                wicketReason: "Invalid Submission",
                message: "Submission too short (min 20 chars). Please elaborate."
            });
        }

        // Reject obvious junk
        const junkPatterns = /^(hi|hello|test|ok|thanks|how are you|\?|wow|cool|testing)$/i;
        if (junkPatterns.test(content.trim())) {
            return NextResponse.json({
                success: true,
                runs: 0,
                wicket: true,
                wicketReason: "Invalid Submission",
                message: "Invalid idea submission."
            });
        }

        // 3. Check for multiple submissions in the same ball window
        const startTime = new Date(match.start_time).getTime();
        const nowMs = now.getTime();
        const totalSeconds = Math.max(0, (nowMs - startTime) / 1000);
        const currentBallIndex = Math.floor(totalSeconds / 10);
        const MAX_BALLS = 20 * 6; // 20 Overs

        if (currentBallIndex >= MAX_BALLS) {
            return NextResponse.json({ error: 'Match has ended (20 Overs Completed)' }, { status: 400 });
        }

        // Check if this team has already submitted for this ball index
        const existingIdeaRs = await db.execute({
            sql: 'SELECT id FROM battle_ideas WHERE match_id = ? AND team_id = ? AND ball_index = ?',
            args: [matchId, teamId, currentBallIndex]
        });
        const existingIdeaForBall = existingIdeaRs.rows[0];

        if (existingIdeaForBall) {
            const colRuns = isTeam1 ? 'score1' : 'score2';

            await db.execute({
                sql: `UPDATE matches SET ${colRuns} = ${colRuns} + 1 WHERE id = ?`,
                args: [matchId]
            });

            // We still record the idea but mark as extra/no-ball
            const ideaId = crypto.randomUUID();
            await db.execute({
                sql: `
                INSERT INTO battle_ideas (id, match_id, team_id, captain_id, content, score, runs, is_wicket, feedback, ball_index, is_extra)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
             `,
                args: [ideaId, matchId, teamId, captainId, content, 0, 1, 0, JSON.stringify({ message: "Extra Idea (No Ball)" }), currentBallIndex, 1]
            });

            return NextResponse.json({
                success: true,
                runs: 1,
                wicket: false,
                message: 'Extra Idea! +1 Run (No Ball)',
                isExtra: true
            });
        }


        // 3b. SEMANTIC RELEVANCE CHECK
        const currentEmbedding = await getEmbedding(content);

        if (currentEmbedding && match.case_description) {
            const caseEmbedding = await getEmbedding(match.case_description);
            if (caseEmbedding) {
                const relevanceScore = cosineSimilarity(currentEmbedding, caseEmbedding);
                console.log("Relevance Score:", relevanceScore);

                if (relevanceScore < 0.12) {
                    const colWickets = isTeam1 ? 'wickets1' : 'wickets2';
                    await db.execute({
                        sql: `UPDATE matches SET ${colWickets} = ${colWickets} + 1 WHERE id = ?`,
                        args: [matchId]
                    });

                    const ideaId = crypto.randomUUID();
                    await db.execute({
                        sql: `
                        INSERT INTO battle_ideas (id, match_id, team_id, captain_id, content, score, runs, is_wicket, feedback, ball_index)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                     `,
                        args: [ideaId, matchId, teamId, captainId, content, 0, 0, 1, JSON.stringify({ message: "Irrelevant Idea", reason: "Low Semantic Relevance" }), currentBallIndex]
                    });

                    return NextResponse.json({
                        success: true,
                        runs: 0,
                        wicket: true,
                        wicketReason: "Irrelevant Idea (< 12% match)",
                        message: "Idea is not relevant to the case."
                    });
                }
            }
        }

        // 4. AI Detection Check
        const aiCheck = await detectAIGenerated(content);
        if (aiCheck.isAI && aiCheck.confidence > 95) {
            const colWickets = isTeam1 ? 'wickets1' : 'wickets2';
            await db.execute({
                sql: `UPDATE matches SET ${colWickets} = ${colWickets} + 1 WHERE id = ?`,
                args: [matchId]
            });

            const ideaId = crypto.randomUUID();
            await db.execute({
                sql: `
                INSERT INTO battle_ideas (id, match_id, team_id, captain_id, content, score, runs, is_wicket, feedback, ball_index)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
             `,
                args: [ideaId, matchId, teamId, captainId, content, 0, 0, 1, JSON.stringify({ message: "AI Detected", reason: "High AI Confidence" }), currentBallIndex]
            });

            return NextResponse.json({
                success: true,
                runs: 0,
                wicket: true,
                wicketReason: "AI Content Detected",
                message: 'AI Content Detected! Wicket lost as penalty.'
            });
        }

        // 5. Duplicate Detection
        const previousIdeasRs = await db.execute({
            sql: 'SELECT content FROM battle_ideas WHERE match_id = ? AND team_id = ?',
            args: [matchId, teamId]
        });
        const previousIdeas = previousIdeasRs.rows as any[];

        if (currentEmbedding) {
            for (const prev of previousIdeas) {
                const prevEmbedding = await getEmbedding(prev.content);
                if (prevEmbedding) {
                    const similarity = cosineSimilarity(currentEmbedding, prevEmbedding);
                    if (similarity > 0.85) {
                        const colWickets = isTeam1 ? 'wickets1' : 'wickets2';
                        await db.execute({
                            sql: `UPDATE matches SET ${colWickets} = ${colWickets} + 1 WHERE id = ?`,
                            args: [matchId]
                        });

                        const ideaId = crypto.randomUUID();
                        await db.execute({
                            sql: `
                            INSERT INTO battle_ideas (id, match_id, team_id, captain_id, content, score, runs, is_wicket, feedback, ball_index)
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                         `,
                            args: [ideaId, matchId, teamId, captainId, content, 0, 0, 1, JSON.stringify({ message: "Duplicate Idea", reason: "Semantic Similarity" }), currentBallIndex]
                        });

                        return NextResponse.json({
                            success: true,
                            runs: 0,
                            wicket: true,
                            wicketReason: "Duplicate Idea",
                            message: 'Duplicate concept identified! Wicket lost.'
                        });
                    }
                }
            }
        } else {
            // Fallback lexical check
            for (const prev of previousIdeas) {
                if (content.toLowerCase().trim() === prev.content.toLowerCase().trim()) {
                    const colWickets = isTeam1 ? 'wickets1' : 'wickets2';
                    await db.execute({
                        sql: `UPDATE matches SET ${colWickets} = ${colWickets} + 1 WHERE id = ?`,
                        args: [matchId]
                    });

                    const ideaId = crypto.randomUUID();
                    await db.execute({
                        sql: `
                        INSERT INTO battle_ideas (id, match_id, team_id, captain_id, content, score, runs, is_wicket, feedback, ball_index)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                     `,
                        args: [ideaId, matchId, teamId, captainId, content, 0, 0, 1, JSON.stringify({ message: "Duplicate Idea", reason: "Exact Match" }), currentBallIndex]
                    });

                    return NextResponse.json({
                        success: true,
                        runs: 0,
                        wicket: true,
                        wicketReason: "Duplicate Idea",
                        message: 'Identical idea detected! Wicket lost.'
                    });
                }
            }
        }

        // 6. Scoring
        const rawScores = await getAIScores(match.case_description, content);
        const weightedScore = calculateWeightedScore(rawScores);
        const result = convertToRuns(weightedScore);

        // 7. Update Database
        const colRuns = isTeam1 ? 'score1' : 'score2';
        const colWickets = isTeam1 ? 'wickets1' : 'wickets2';
        const colBalls = isTeam1 ? 'balls1' : 'balls2';
        const colOvers = isTeam1 ? 'overs1' : 'overs2';

        const newTotalBalls = (isTeam1 ? match.balls1 : match.balls2) + 1;
        const overs = Math.floor(newTotalBalls / 6);
        const balls = newTotalBalls % 6;
        const cricketOver = overs + (balls / 10); // e.g. 1.2

        await db.execute({
            sql: `
            UPDATE matches 
            SET ${colRuns} = ${colRuns} + ?, 
                ${colWickets} = ${colWickets} + ?,
                ${colBalls} = ${colBalls} + 1,
                ${colOvers} = ?
            WHERE id = ?
        `,
            args: [result.runs, result.wicket ? 1 : 0, cricketOver, matchId]
        });

        const ideaId = crypto.randomUUID();
        // Helper for commentary
        const getCommentary = (runs: number, wicket: boolean) => {
            if (wicket) return "OH NO! Clean bowled! The idea didn't stand a chance.";
            if (runs === 6) return "MASSIVE HIT! That's out of the park! Pure genius!";
            if (runs === 4) return "CRACKING SHOT! Races to the boundary for 4!";
            if (runs === 3) return "Great running! Uses the gaps well.";
            if (runs === 2) return "Solid execution, pushes for a couple.";
            if (runs === 1) return "Just a single. Rotates the strike.";
            return "Straight to the fielder. No run.";
        };

        const commentary = getCommentary(result.runs, result.wicket);

        const feedbackFunc = {
            message: result.wicket ? "Wicket!" : `${result.runs} Runs`,
            reason: result.wicket ? "Low Innovation" : null,
            commentary: commentary,
            breakdown: rawScores // Adding breakdown for progress bars
        };

        await db.execute({
            sql: `
    INSERT INTO battle_ideas (id, match_id, team_id, captain_id, content, score, runs, is_wicket, feedback, ball_index)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`,
            args: [ideaId, matchId, teamId, captainId, content, weightedScore, result.runs, result.wicket ? 1 : 0, JSON.stringify(feedbackFunc), currentBallIndex]
        });

        return NextResponse.json({
            success: true,
            runs: result.runs,
            wicket: result.wicket,
            wicketReason: result.wicket ? "Low Innovation Score (< 40)" : null,
            score: weightedScore,
            breakdown: rawScores,
            commentary: commentary
        });

    } catch (error) {
        console.error('Submission error:', error);
        return NextResponse.json({ error: 'Failed to submit idea' }, { status: 500 });
    }
}
